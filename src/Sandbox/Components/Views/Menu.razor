@using Sandbox.Game
@implements IDisposable

@inject NetworkManager NetworkManager

<Stack ClassName="w-fit border p-5 m-2">
    <TextBox Placeholder="Pseudo"/>
    <Separator ClassName="my-1"/>
    <Stack Horizontal="true">
        <TextBox Placeholder="Address" ClassName="grow" @bind-Value="_address"/>
        <Separator ClassName="mr-1"/>
        <TextBox Placeholder="Port" ClassName="w-1/4" @bind-Value="_port"/>
    </Stack>
    <Separator ClassName="my-2 border-t border-gray-400"/>
    <Stack Horizontal="true">
        <PrimaryButton Text="Start Server" Icon="Server" ClassName="w-full" OnClick="StartServer"
                       Disabled="IsServerRunning || IsClientStarted"/>
        <Separator ClassName="mx-1"/>
        <PrimaryButton Text="Start Client" Icon="ConnectContacts" ClassName="w-full" OnClick="StartClient"
                       Disabled="IsClientRunning"/>
    </Stack>
    <Separator ClassName="my-1"/>
    <DefaultButton Text="Disconnect" Icon="ReturnKey" OnClick="Disconnect"
                   Enabled="IsServerRunning || IsClientRunning"/>
</Stack>

<Stack Horizontal="true">
    @foreach (var item in NetworkManager.Query<Player>())
    {
        <p class="p-3 border w-fit m-2">@item.Id</p>
    }
</Stack>

<Stack Horizontal="true" ClassName="ml-2">
    <DefaultButton Text="Spawn" OnClick="Spawn"/>
    <Separator ClassName="mx-1"/>
    <DefaultButton Text="Destroy" OnClick="Destroy"/>
</Stack>

@if (IsServerRunning || IsClientRunning)
{
    <Stack>
        @if (_entity?.IsValid == true)
        {
            <p>@_entity.Value</p>
        }
    </Stack>
}

@code {

    private string _address = null!;
    private string _port = null!;
    private Entity? _entity;

    private bool IsServerRunning => NetworkManager.ServerManager.IsRunning;
    private bool IsClientRunning => NetworkManager.ClientManager.IsRunning;
    private bool IsClientStarted => NetworkManager.ClientManager.ConnectionState == ConnectionState.Started;

    protected override void OnInitialized()
    {
        NetworkManager.ServerManager.ConnectionStateChangedEvent += OnServerConnectionStateChanged;
        NetworkManager.ClientManager.ConnectionStateChangedEvent += OnClientConnectionStateChanged;
        NetworkManager.SpawnNetworkObjectEvent += OnSpawnNetworkObjectEvent;
        NetworkManager.DestroyNetworkObjectEvent += OnDestroyNetworkObject;

        _entity = NetworkManager.Query<Entity>().FirstOrDefault();
    }

    public void Dispose()
    {
        NetworkManager.ServerManager.ConnectionStateChangedEvent -= OnServerConnectionStateChanged;
        NetworkManager.ClientManager.ConnectionStateChangedEvent -= OnClientConnectionStateChanged;
        NetworkManager.SpawnNetworkObjectEvent -= OnSpawnNetworkObjectEvent;
        NetworkManager.DestroyNetworkObjectEvent -= OnDestroyNetworkObject;
    }

    private int? GetPort()
    {
        if (int.TryParse(_port, out var result))
        {
            return result;
        }

        return null;
    }

    private void StartServer()
    {
        NetworkManager.StartServer(GetPort());
    }

    private void StartClient()
    {
        NetworkManager.StartClient(_address, GetPort());
    }

    private void Disconnect()
    {
        NetworkManager.StopClient();
        NetworkManager.StopServer();
    }

    private void OnServerConnectionStateChanged(ConnectionState state)
    {
        InvokeAsync(StateHasChanged);
    }

    private void OnClientConnectionStateChanged(ConnectionState state)
    {
        InvokeAsync(StateHasChanged);
    }

    private void OnSpawnNetworkObjectEvent(NetworkObject networkObject)
    {
        if (networkObject is Entity entity)
        {
            _entity = entity;
        }
        InvokeAsync(StateHasChanged);
    }

    private void OnDestroyNetworkObject()
    {
        InvokeAsync(StateHasChanged);
    }

    private void Spawn()
    {
        var entity = new Entity();
        entity.Spawn();
    }

    private void Destroy()
    {
        _entity?.Destroy();
    }

}